@using Despro.Blazor.Base.Components
@using Despro.Blazor.Layout.Components.Icons
@using Despro.Blazor.Layout.Components.IconsModel
@using Microsoft.JSInterop
@inherits BaseComponent

<label class="form-label">@Label</label>
<div class="drop-zone @(_isFile ? "has-preview" : "")">
    <div class="drop-zone-message">
        <div style="justify-items: center;">
            <Icon IconType="MDIcons.Cloud_upload_outline" Color="#a8a7a7" Size="80" />
        </div>
        <div @ref="_dropZoneElement">
            <p>یک فایل را در اینجا بکشید و رها کنید یا کلیک کنید</p>
        </div>
    </div>
    <InputFile OnChange="@OnChange" accept="image/*,video/*" @ref="_inputFile" />
    <button type="button" class="btn drop-zone-clear" @onclick="OnRemoveFile" style="@(!_isFile ? "display:none" : "")">
        حذف
    </button>

    @if (_isFile)
    {
        <div class="drop-zone-preview" style="display: block;">
            <span class="drop-zone-render" style="text-align: -webkit-center;">
                @if (IsVideo)
                {
                    <video controls src="@_previewSrc" class="drop-zone-media"></video>
                }
                else
                {
                    <img src="@_previewSrc" alt="" class="drop-zone-media" />
                }
            </span>
            <div class="drop-zone-infos">
                <div class="drop-zone-infos-inner">
                    <p class="drop-zone-filename">
                        <span class="file-icon"></span>
                        <span>@(SelectedFile?.Name ?? Path.GetFileName(Src))</span>
                    </p>
                    <p class="drop-zone-infos-message">برای جایگزینی بکشید و رها کنید یا کلیک کنید</p>
                </div>
            </div>
        </div>
    }
</div>

@code {
    [Inject] private IJSRuntime JsRuntime { get; set; }

    [Parameter] public EventCallback<IBrowserFile> SelectedFileChanged { get; set; }
    [Parameter] public IBrowserFile SelectedFile { get; set; }
    [Parameter] public string Label { get; set; }
    [Parameter] public string? Src { get; set; }
    [Parameter] public bool IsWebSrc { get; set; }

    private ElementReference _dropZoneElement;
    private InputFile _inputFile;
    private IJSObjectReference _module;
    private IJSObjectReference _dropZoneInstance;

    private bool _isFile = false;
    private string _previewSrc = "";
    private string _objectUrl;
    private bool _disposed;

    private bool IsVideo => (SelectedFile?.ContentType?.StartsWith("video/") ?? false);
    // || (!string.IsNullOrEmpty(Src) && GetMimeType(Src).StartsWith("video/"));

    protected override async Task OnInitializedAsync()
    {
        if (!string.IsNullOrEmpty(Src))
        {
            _isFile = true;

            if (IsWebSrc)
            {
                _previewSrc = Src;
            }
            else
            {
                try
                {
                    var fileInfo = new FileInfo(Src);
                    if (fileInfo is { Exists: true, Length: <= 50 * 1024 * 1024 })
                    {
                        await using var stream = fileInfo.OpenRead();
                        using var ms = new MemoryStream();
                        await stream.CopyToAsync(ms);
                        var base64 = Convert.ToBase64String(ms.ToArray());
                        var mime = GetMimeType(Src);
                        _previewSrc = $"data:{mime};base64,{base64}";
                    }
                    else
                    {
                        _previewSrc = "/placeholder-video.png";
                    }
                }
                catch
                {
                    _previewSrc = "/placeholder-error.png";
                    _isFile = false;
                }
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_disposed) return;
        if (firstRender)
        {
            _module = await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./_content/Despro.Blazor.Base/js/dropZone.min.js");
            if (_disposed) return;

            _dropZoneInstance = await _module.InvokeAsync<IJSObjectReference>("initializeFileDropZone", _dropZoneElement, _inputFile.Element);
        }
    }

    private async Task OnChange(InputFileChangeEventArgs e)
    {
        SelectedFile = e.File;
        _isFile = true;

        if (!string.IsNullOrEmpty(_objectUrl))
        {
            await _module.InvokeVoidAsync("revokeObjectUrl", _objectUrl);
        }

        _objectUrl = await _module.InvokeAsync<string>("setFilePreview", _inputFile.Element);
        _previewSrc = _objectUrl;

        StateHasChanged();
        await SelectedFileChanged.InvokeAsync(e.File);
    }

    private async Task OnRemoveFile()
    {
        if (!string.IsNullOrEmpty(_objectUrl))
        {
            await _module.InvokeVoidAsync("revokeObjectUrl", _objectUrl);
            _objectUrl = null;
        }

        _previewSrc = "";
        SelectedFile = null;
        _isFile = false;
        await SelectedFileChanged.InvokeAsync(null);
    }

    private string GetMimeType(string path)
    {
        var ext = Path.GetExtension(path)?.ToLowerInvariant() ?? "";
        return ext switch
        {
            ".png" => "image/png",
            ".jpg" or ".jpeg" => "image/jpeg",
            ".gif" => "image/gif",
            ".webp" => "image/webp",
            ".mp4" => "video/mp4",
            ".webm" => "video/webm",
            ".ogg" => "video/ogg",
            _ => "application/octet-stream"
        };
    }

    // public async ValueTask DisposeAsync()
    // {
    //     try
    //     {
    //         _disposed = true;

    //         if (!string.IsNullOrEmpty(_objectUrl))
    //             await _module.InvokeVoidAsync("revokeObjectUrl", _objectUrl);

    //         if (_dropZoneInstance != null)
    //             await _dropZoneInstance.InvokeVoidAsync("dispose");

    //         if (_dropZoneInstance is not null)
    //             await _dropZoneInstance.DisposeAsync();

    //         if (_module is not null)
    //             await _module.DisposeAsync();
    //     }
    //     catch { /* ignored */ }
    // }
}